const express = require('express');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const nodemailer = require('nodemailer');
const axios = require('axios');

const app = express();
app.use(express.json());

// Store logs for debugging
let recentLogs = [];
function log(message, level = 'info') {
  const timestamp = new Date().toISOString();
  const logEntry = { timestamp, level, message };
  recentLogs.push(logEntry);
  if (recentLogs.length > 100) recentLogs.shift();
  console.log(`[${timestamp}] ${level.toUpperCase()}: ${message}`);
}

// Gmail setup
const transporter = nodemailer.createTransporter({
  service: 'gmail',
  auth: {
    user: process.env.GMAIL_EMAIL,
    pass: process.env.GMAIL_PASSWORD
  }
});

// Airtable setup
const AIRTABLE_API_KEY = process.env.AIRTABLE_API_KEY;
const AIRTABLE_BASE_ID = 'appUNIsu8KgvOlmi0';
const AIRTABLE_TABLE_NAME = 'Failed Payments';

// Add failed payment to Airtable
async function addFailedPaymentToAirtable(paymentData) {
  try {
    const record = {
      fields: {
        'Payment ID': paymentData.id || 'N/A',
        'Customer ID': paymentData.customer || 'N/A',
        'Customer Email': paymentData.billing_details?.email || paymentData.receipt_email || 'N/A',
        'Amount': paymentData.amount ? (paymentData.amount / 100).toString() : 'N/A',
        'Currency': paymentData.currency?.toUpperCase() || 'USD',
        'Failure Reason': paymentData.failure_message || paymentData.outcome?.seller_message || 'Unknown',
        'Failure Code': paymentData.failure_code || paymentData.outcome?.network_status || 'N/A',
        'Date': new Date().toISOString(),
        'Status': 'Failed'
      }
    };

    const response = await axios.post(
      `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${encodeURIComponent(AIRTABLE_TABLE_NAME)}`,
      { records: [record] },
      {
        headers: {
          'Authorization': `Bearer ${AIRTABLE_API_KEY}`,
          'Content-Type': 'application/json'
        }
      }
    );

    log(`Added failed payment to Airtable: ${paymentData.id}`);
    return response.data;
  } catch (error) {
    log(`Error adding to Airtable: ${error.message}`, 'error');
    throw error;
  }
}

// Send Gmail alert
async function sendGmailAlert(paymentData) {
  try {
    const customerInfo = paymentData.billing_details?.email || paymentData.receipt_email || 'Unknown';
    const amount = paymentData.amount ? `$${(paymentData.amount / 100).toFixed(2)}` : 'Unknown';
    const reason = paymentData.failure_message || paymentData.outcome?.seller_message || 'Unknown reason';

    const mailOptions = {
      from: process.env.GMAIL_EMAIL,
      to: process.env.GMAIL_EMAIL,
      subject: 'ðŸš¨ Stripe Payment Failed Alert',
      html: `
        <h2>Payment Failure Alert</h2>
        <p><strong>Payment ID:</strong> ${paymentData.id}</p>
        <p><strong>Customer:</strong> ${customerInfo}</p>
        <p><strong>Amount:</strong> ${amount} ${paymentData.currency?.toUpperCase() || 'USD'}</p>
        <p><strong>Failure Reason:</strong> ${reason}</p>
        <p><strong>Date:</strong> ${new Date().toLocaleString()}</p>
        
        <hr>
        <p><small>This alert was automatically generated by your Stripe Payment Monitor agent.</small></p>
      `
    };

    await transporter.sendMail(mailOptions);
    log(`Gmail alert sent for payment: ${paymentData.id}`);
  } catch (error) {
    log(`Error sending Gmail alert: ${error.message}`, 'error');
    throw error;
  }
}

// Webhook endpoint for Stripe events
app.post('/webhook/stripe', async (req, res) => {
  try {
    const event = req.body;
    log(`Received Stripe webhook: ${event.type}`);

    let paymentData = null;
    
    switch (event.type) {
      case 'payment_intent.payment_failed':
        paymentData = event.data.object;
        break;
      case 'charge.failed':
        paymentData = event.data.object;
        break;
      case 'invoice.payment_failed':
        paymentData = event.data.object;
        break;
      case 'subscription.payment_failed':
        paymentData = event.data.object;
        break;
      default:
        log(`Unhandled event type: ${event.type}`);
        return res.status(200).json({ received: true });
    }

    if (paymentData) {
      log(`Processing failed payment: ${paymentData.id}`);
      
      await Promise.all([
        addFailedPaymentToAirtable(paymentData),
        sendGmailAlert(paymentData)
      ]);

      log(`Successfully processed failed payment: ${paymentData.id}`);
    }

    res.status(200).json({ received: true });
  } catch (error) {
    log(`Error processing webhook: ${error.message}`, 'error');
    res.status(500).json({ error: 'Webhook processing failed' });
  }
});

// Standard endpoints
app.get('/', (req, res) => {
  res.json({
    name: 'Stripe Payment Monitor',
    description: 'Monitors Stripe for failed payments and sends alerts via Gmail and Airtable',
    endpoints: {
      'GET /': 'This status page',
      'GET /health': 'Health check',
      'GET /logs': 'View recent logs',
      'POST /test': 'Manual test run',
      'POST /webhook/stripe': 'Stripe webhook endpoint'
    },
    status: 'running'
  });
});

app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

app.get('/logs', (req, res) => {
  res.json({
    logs: recentLogs.slice(-50),
    count: recentLogs.length
  });
});

app.post('/test', async (req, res) => {
  try {
    log('Manual test initiated');
    
    const testPaymentData = {
      id: 'pi_test_' + Date.now(),
      customer: 'cus_test123',
      billing_details: { email: 'test@example.com' },
      amount: 2500,
      currency: 'usd',
      failure_message: 'Test failure - insufficient funds',
      failure_code: 'card_declined'
    };

    await Promise.all([
      addFailedPaymentToAirtable(testPaymentData),
      sendGmailAlert(testPaymentData)
    ]);

    log('Manual test completed successfully');
    res.json({ 
      success: true, 
      message: 'Test completed - check your email and Airtable',
      testData: testPaymentData
    });
  } catch (error) {
    log(`Test failed: ${error.message}`, 'error');
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  log(`Stripe Payment Monitor agent running on port ${PORT}`);
});

module.exports = app;